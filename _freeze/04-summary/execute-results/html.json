{
  "hash": "3a9e840bc1e01c2b19c6a44223277c80",
  "result": {
    "engine": "knitr",
    "markdown": "# Data Summaries {#sec-summary}\n\n## Intended Learning Outcomes {#sec-ilo-summary .unnumbered}\n\n-   Be able to load data from external files\n-   Be able to summarise data by groups\n-   Use pipes to chain together functions\n\n## Functions used {#functions-summary}\n\n\n\n\n\n\n\n\n\n\n\n-   built-in (you can always use these without loading any packages)\n    -   base:: `c()`, `dput()`, `library()`, `max()`, `mean()`, `min()`, `sum()`\n    -   stats:: `quantile()`\n    -   utils:: `head()`\n-   tidyverse (you can use all these with `library(tidyverse)`)\n    -   readr:: `cols()`, `col_factor()`, `col_skip()`, `read_csv()`, `spec()`\n    -   dplyr:: `arrange()`, `count()`, `desc()`, `filter()`, `glimpse()`, `group_by()`, `median()`, `mutate()`, `n()`, `summarise()`, `ungroup()`\n-   other (you need to load each package to use these)\n    -   janitor:: `clean_names()`\n\n## Walkthrough video {#sec-walkthrough-summary .unnumbered}\n\nThere is a walkthrough video of this chapter available via [Echo360](https://echo360.org.uk/media/7684e5ec-5ca7-44e4-9a22-f46f21da498c/public). Please note that there may have been minor edits to the book since the video was recorded. Where there are differences, the book should always take precedence.\n\n## Set-up {#sec-setup-summary}\n\nFirst, create a new project for the work we'll do in this chapter named <code class='path'>04-summary</code>. Second, download the data for this chapter (<a href=\"data/12.1_delivery.csv\" download>12.1_delivery.csv</a>) and save it in your project data folder. Finally, open and save and new R Markdown document named `summary.Rmd`, delete the welcome text and load the required packages for this chapter.\n\n\n\n\n\n::: {.cell layout-align=\"center\" filename='Chapter packages'}\n\n```{.r .cell-code}\nlibrary(tidyverse)   # data wrangling functions\nlibrary(janitor)     # data cleaning functions\n```\n:::\n\n\n\n\n\nDownload the [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf).\n\n## Import Data\n\nThe data we'll be working with is on method of delivery for singleton births from Public Health Scotland. You can see the most recent version at [Method of Delivery](https://www.opendata.nhs.scot/dataset/births-in-scottish-hospitals/resource/8654b6d8-9765-4ced-8e9b-4611aa4596eb), but we'll be working from a saved version.\n\nThe data are in a <a href='https://psyteachr.github.io/glossary/c#csv' target='_blank' class='glossary' title='Comma-separated variable: a file type for representing data where each variable is separated from the next by a comma.'>CSV</a> file (download <a href=\"data/12.1_delivery.csv\" download>12.1_delivery.csv</a>), so we can read this with the function `read_csv()` , and assign it to a new object that we'll call `births`. You can learn more about importing data from other file types in @sec-data.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths <- read_csv(\"data/12.1_delivery.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 97077 Columns: 9\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (7): FinancialYear, CA, SIMDQuintileQF, SIMDVersion, AgeGroup, Delivery,...\ndbl (2): SIMDQuintile, Livebirths\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n:::\n\n\n\n\n\nWhen you load data with `read_csv()`, you get a quick summary that you should always check to see if the data were loaded correctly. One common problem is that data load with the the wrong type (see @sec-data-types), usually because a numeric column contains some unexpected text values. So the first thing to check is that each column has the expected data type. The abbreviation \"chr\" means this is a <a href='https://psyteachr.github.io/glossary/c#character' target='_blank' class='glossary' title='A data type representing strings of text.'>character</a> column, which can contain any text. The abbreviation \"dbl\" is a <a href='https://psyteachr.github.io/glossary/d#double' target='_blank' class='glossary' title='A data type representing a real decimal number'>double</a>, which is a number that can have decimal places.\n\n<details>\n<summary>This is the abridged version! Click for additional context.</summary>\nThere are too many columns to show all of them in the summary, so it tells you to use the `spec()` function to check all the columns.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nspec(births)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncols(\n  FinancialYear = col_character(),\n  CA = col_character(),\n  SIMDQuintile = col_double(),\n  SIMDQuintileQF = col_character(),\n  SIMDVersion = col_character(),\n  AgeGroup = col_character(),\n  Delivery = col_character(),\n  Induced = col_character(),\n  Livebirths = col_double()\n)\n```\n\n\n:::\n:::\n\n\n\n\n\nThis gives you the info formatted inside the `cols()` function to make it easy for you to copy and edit this if any of the columns imported incorrectly.\n\nYou can also use the `glimpse()` function to check the type of each column, and see a few examples of the cell values.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nglimpse(births)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 97,077\nColumns: 9\n$ FinancialYear  <chr> \"1997/98\", \"1997/98\", \"1997/98\", \"1997/98\", \"1997/98\", …\n$ CA             <chr> \"RA2704\", \"RA2704\", \"RA2704\", \"RA2704\", \"RA2704\", \"RA27…\n$ SIMDQuintile   <dbl> NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA, NA,…\n$ SIMDQuintileQF <chr> \":\", \":\", \":\", \":\", \":\", \":\", \":\", \":\", \":\", \":\", \":\", …\n$ SIMDVersion    <chr> \"SIMD2004\", \"SIMD2004\", \"SIMD2004\", \"SIMD2004\", \"SIMD20…\n$ AgeGroup       <chr> \"25-34\", \"25-34\", \"25-34\", \"25-34\", \"25-34\", \"25-34\", \"…\n$ Delivery       <chr> \"Caesarean - Elective\", \"Caesarean - Emergency\", \"Caesa…\n$ Induced        <chr> \"Not Induced\", \"Induced\", \"Not Induced\", \"Induced\", \"No…\n$ Livebirths     <dbl> 9, 5, 8, 1, 6, 21, 60, 4, 4, 3, 1, 1, 1, 14, 2, 6, 1, 7…\n```\n\n\n:::\n:::\n\n\n\n\n\nThe column `SIMDQuintileQF` looks a little odd. We can quickly check what all the values are in a data table with the `count()` function:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncount(births, SIMDQuintileQF)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|SIMDQuintileQF |     n|\n|:--------------|-----:|\n|:              |  1137|\n|NA             | 95940|\n\n</div>\n:::\n:::\n\n\n\n\n\nIt looks like this column doesn't contain any useful info, so we can just ignore it, or skip it. To do this at the point of loading in the data, we create an object (`birth_cols`) that contains our column specification using the `col_types` argument and two helper functions, `cols()` and `col_skip()`. We then pass `birth_cols` to the `col_types` argument of `read_csv()` which uses this info to amend the file that is loaded in.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# edit the output of spec(births)\nbirth_cols <- cols(\n  SIMDQuintileQF = col_skip()\n)\n\nbirths <- read_csv(\"data/12.1_delivery.csv\", col_types = birth_cols)\n```\n:::\n\n\n\n\n\nThere's also additional edits you can make to the initial file, for example, you can also set the order of levels for <a href='https://psyteachr.github.io/glossary/c#categorical' target='_blank' class='glossary' title='Data that can only take certain values, such as types of pet.'>categorical</a> data when you first import it.\n\nTo check which groups our data has, we can use the `count()` function to check the level labels for `AgeGroup`, `Delivery` and `Induced`; and set `sort = TRUE` to sort by frequency.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncount(births, AgeGroup)\ncount(births, Delivery, sort = TRUE)\ncount(births, Induced, sort = TRUE)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|AgeGroup    |     n|\n|:-----------|-----:|\n|25-34       | 37557|\n|35 and over | 29592|\n|Under 25    | 29918|\n|Unknown     |    10|\n\n</div><div class=\"kable-table\">\n\n|Delivery              |     n|\n|:---------------------|-----:|\n|Spontaneous           | 25607|\n|Caesarean - Emergency | 22526|\n|Forceps               | 19041|\n|Vacuum                | 14573|\n|Caesarean - Elective  | 12417|\n|Breech                |  2483|\n|Not Known             |   430|\n\n</div><div class=\"kable-table\">\n\n|Induced     |     n|\n|:-----------|-----:|\n|Not Induced | 54217|\n|Induced     | 39097|\n|Unknown     |  3763|\n\n</div>\n:::\n:::\n\n\n\n\n\nWe'll now add on extra code to `birth_cols` to set the order of our factors. What order you choose will depend on what makes most sense for the data. For `AgeGroup` we'll list them in chronological order, whilst for `Delivery` and `Induced`, we'll sort them according to the highest value - it can be helpful to think of what order you'll like the bars to be in if you were making a graph.\n\n::: callout-tip\nThe levels for `Delivery` are numerous and complex, which increases the risk of a typo and is just tedious to type. Here is a quick trick to generate the text you can copy and paste into your code. The function `dput()` gives you the code you can use to recreate an object.\n\n\n\n\n\n::: {.cell layout-align=\"center\" filename='Type in the console'}\n\n```{.r .cell-code}\ndelivery_table <- count(births, Delivery, sort = TRUE)\ndput(delivery_table$Delivery)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nc(\"Spontaneous\", \"Caesarean - Emergency\", \"Forceps\", \"Vacuum\", \n\"Caesarean - Elective\", \"Breech\", \"Not Known\")\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# edit the output of spec(births)\nbirth_cols <- cols(\n  SIMDQuintileQF = col_skip(),\n  AgeGroup = col_factor(levels = c(\"Under 25\", \"25-34\", \"35 and over\",\"Unknown\")),\n  Delivery = col_factor(levels = c(\"Spontaneous\", \n                                   \"Caesarean - Emergency\", \n                                   \"Forceps\", \n                                   \"Vacuum\", \n                                   \"Caesarean - Elective\", \n                                   \"Breech\", \n                                   \"Not Known\")),\n  Induced = col_factor(levels = c(\"Not Induced\", \"Induced\", \"Unknown\"))\n)\n\nbirths <- read_csv(\"data/12.1_delivery.csv\", col_types = birth_cols)\n```\n:::\n\n\n\n\n\n</details>\n\n### Clean up names\n\nData sets often import with column names that are a little difficult to use in code. You can manually rename them, but the <pkg>janitor</pkg> package makes this incredibly easy. This dataset has pretty good names, with no spaces or special characters, but it does use uppercase letters to separate words, which can be hard to remember. the `clean_names()` function changes everything to lowercase and uses underscores to separate word parts. Using `clean_names` every time you import a dataset is a good habit to get into.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths <- clean_names(births)\n\ncolnames(births)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"financial_year\" \"ca\"             \"simd_quintile\"  \"simd_version\"  \n[5] \"age_group\"      \"delivery\"       \"induced\"        \"livebirths\"    \n```\n\n\n:::\n:::\n\n\n\n\n\n### Exploring a Dataset\n\nThere are 97077 rows and 8 columns of data. The data dictionary on the NHS website includes the following, but doesn't clearly state what the possible values are for each column. We're going to practice figuring out more about how data is structured using data summaries in this exercise, since it's a common task to get a mysteriously formatted data file and need to figure it out yourself. At the very least, this exercise should remind you to never do this to other people -- always provide a clear codebook with all values!\n\n| Column | Type | Label |\n|:-------------------------|:----------------------|:----------------------|\n| FinancialYear | text | Data is recorded for financial years (1st April to 31st March) based on the date of the mother's discharge |\n| CA | text | 9-digit code for Council areas based on boundaries as at 1st April 2019 |\n| SIMDQuintile | text | Scottish Index of Multiple Deprivation (SIMD) quintile; 1(Most Deprived) - 5(Least Deprived) |\n| SIMDQuintileQF | text | Qualifier for SIMDQuintile indicating unknown quintiles |\n| SIMDVersion | text | Most appropriate SIMD release used for each year |\n| AgeGroup | text | Age Group of the mother at time of admission |\n| Delivery | text | The method by which the baby was delivered |\n| Induced | text | Was the delivery induced, that is, was it started artificially |\n| Livebirths | numeric | Number of live births |\n\n: Data Codebook {tbl-colwidths=\"\\[25,25,50\\]\"}\n\n### The \\$ operator\n\nWe need to take a couple of brief detours to introduce some additional coding conventions. First, let's introduce the `$` notation. The dollar sign allows you to select items from some objects, like lists or data frames. The left-hand side is the object, and the right-hand side is the item. Here, we will select columns from a table. When you call a column like this, R will return all the observations in that column.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nyears <- births$financial_year\n```\n:::\n\n\n\n\n\nIf your item has multiple observations, you can specify which ones to return using square brackets `[]` and the row number or a <a href='https://psyteachr.github.io/glossary/v#vector' target='_blank' class='glossary' title='A type of data structure that collects values with the same data type, like T/F values, numbers, or strings.'>vector</a> of row numbers.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths$financial_year[1] # select the first observation\nbirths$livebirths[c(20,30,40)] # select multiple with c()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1997/98\"\n[1]  2 42  3\n```\n\n\n:::\n:::\n\n\n\n\n\n## Pipes {#sec-pipes-first}\n\n::: {style=\"width: 200px; float: right;\"}\n<img src=\"images/tidy/pipe_sticker.png\" style=\"width: 100%\"/>\n:::\n\nLet's say you want to filter the dataset down to just the emergency C-sections, and then sum up the total number of live births per year, and then arrange the data from largest to smallest (don't worry, we'll introduce these functions soon). You could do it by creating intermediate objects for each step:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# filter the table to just emergency c-sections\nc_sections <- filter(births, \n                     delivery == \"Caesarean - Emergency\")\n\n# calculate the total number of births per year\nc_per_year <- summarise(c_sections, \n                        n = sum(livebirths), \n                        .by = financial_year)\n\n# sort by n, descending\nc_sorted <- arrange(c_per_year, desc(n))\n\nhead(c_sorted)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|financial_year |    n|\n|:--------------|----:|\n|2014/15        | 8964|\n|2015/16        | 8958|\n|2021/22        | 8920|\n|2011/12        | 8916|\n|2013/14        | 8810|\n|2022/23        | 8739|\n\n</div>\n:::\n:::\n\n\n\n\n\nWhilst the above code is functional, it adds three unnecessary objects to the environment, increasing cognitive load and the risk of mistakes. Enter... the <a href='https://psyteachr.github.io/glossary/p#pipe' target='_blank' class='glossary' title='A way to order your code in a more readable format using the symbol %&gt;%'>pipe</a>, that weird `%>%` you may have seen.\n\nPipes allow you to send the output from one function straight into another function. Specifically, they send the result of the function before `%>%` to be an argument in the function after `%>%`. By default, this is the first argument, but we'll show you ways to change that later.\n\nIt can be useful to translate the pipe as \"**and then**\". It's easier to show than tell, so let's look at an example.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nc_per_year <- births %>% # and then\n  \n  filter(delivery == \"Caesarean - Emergency\") %>% # and then\n  \n  summarise(n = sum(livebirths), \n            .by = financial_year) %>% # and then\n  \n  arrange(desc(n))\n\nhead(c_per_year)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|financial_year |    n|\n|:--------------|----:|\n|2014/15        | 8964|\n|2015/16        | 8958|\n|2021/22        | 8920|\n|2011/12        | 8916|\n|2013/14        | 8810|\n|2022/23        | 8739|\n\n</div>\n:::\n:::\n\n\n\n\n\nNotice that `filter()`, `summarise()` and `arrange()` no longer need the first argument to be the data table; it is pulled in from the pipe above. The power of the pipe may not be obvious now, but it will soon prove its worth.\n\n<details>\n<summary>This is the abridged version! Click for additional context.</summary>\n\n::: callout-note\nBase R recently added a \"native pipe\" that looks like this: `|>`, while the tidyverse has traditionally used the \"magrittr pipe\" that looks like this `%>%`. They have a few small differences that you don't need to learn about yet. We'll be using the magrittr pipe, but you might see the base R pipe in other sources.\n:::\n\n</details>\n\n## Counting\n\nYou can count categorical data with the `count()` function. This will give you a new table with each combination of the counted columns and a column called `n` containing the number of rows from that group.\n\nLet's figure out how many entries there were per delivery type. The first argument is the name of the data table object, and the second argument is the name of the column we want to count.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncount(births, delivery)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|delivery              |     n|\n|:---------------------|-----:|\n|Spontaneous           | 25607|\n|Caesarean - Emergency | 22526|\n|Forceps               | 19041|\n|Vacuum                | 14573|\n|Caesarean - Elective  | 12417|\n|Breech                |  2483|\n|Not Known             |   430|\n\n</div>\n:::\n:::\n\n\n\n\n\nThere are 7 types of deliveries, and the new column `n` tells you how many rows of the data table there are per type.\n\n<details>\n<summary>This is the abridged version! Click for additional context.</summary>\n\nYou can add on a column with the numbers expressed in percent using the function `mutate()`. We'll go into more detail on how to use `mutate()` in @sec-wrangle, but for now, it can be used to add new columns or overwrite existing columns.\n\nThe code below divides the value in the `n` column by the total sum of the numbers in that column, and adds it to a new column called `percent`. The next step modifies the percent column by multiplying it by 100 and rounding the value. You could do this all in one step, like `round(100 * n / sum(n))`, but often it's clearer to break it into a few steps to avoid too many nested parentheses.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncount(births, delivery) %>%\n  mutate(percent = n / sum(n),\n         percent = round(100 * percent))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|delivery              |     n| percent|\n|:---------------------|-----:|-------:|\n|Spontaneous           | 25607|      26|\n|Caesarean - Emergency | 22526|      23|\n|Forceps               | 19041|      20|\n|Vacuum                | 14573|      15|\n|Caesarean - Elective  | 12417|      13|\n|Breech                |  2483|       3|\n|Not Known             |   430|       0|\n\n</div>\n:::\n:::\n\n\n\n\n</details>\n\nWe can also count combinations of columns by adding more arguments. The table below shows the number of rows per age group and induction status, sorted by the number of rows. We won't add on percent just yet as the additional variable requires another function that we'll come back to later.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncount(births, age_group, induced, sort = TRUE)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|age_group   |induced     |     n|\n|:-----------|:-----------|-----:|\n|25-34       |Not Induced | 20441|\n|35 and over |Not Induced | 16965|\n|Under 25    |Not Induced | 16805|\n|25-34       |Induced     | 15176|\n|Under 25    |Induced     | 12206|\n|35 and over |Induced     | 11711|\n|25-34       |Unknown     |  1940|\n|35 and over |Unknown     |   916|\n|Under 25    |Unknown     |   907|\n|Unknown     |Not Induced |     6|\n|Unknown     |Induced     |     4|\n\n</div>\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n\n\n::: {.callout-note .try}\nHow would you create the table of counts below?\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|induced     |     n|\n|:-----------|-----:|\n|Not Induced | 54217|\n|Induced     | 39097|\n|Unknown     |  3763|\n\n</div>\n:::\n:::\n\n\n\n\n\n<div class='webex-radiogroup' id='radio_CZVMWWYOLN'><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_CZVMWWYOLN\" value=\"x\"></input> <span>`count(induced, births, sort = TRUE)`</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_CZVMWWYOLN\" value=\"x\"></input> <span>`count(induced, births)`</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_CZVMWWYOLN\" value=\"answer\"></input> <span>`count(births, induced, sort = TRUE)`</span></label><label><input type=\"radio\" autocomplete=\"off\" name=\"radio_CZVMWWYOLN\" value=\"x\"></input> <span>`count(births, induced)`</span></label></div>\n\n:::\n\nHowever, the numbers above are not the number of births, but rather the number of rows in the data set. The column `live_births` contains the number per each category, so we will need to add those numbers together to see the total number of births.\n\n## Summarise {#sec-summary-summarise}\n\nThe `summarise()` function from the <pkg>dplyr</pkg> package is loaded as part of the tidyverse and creates summary statistics. It creates a new table with columns that summarise the data from a larger table using summary functions. Check the [Data Transformation Cheat Sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf) for various summary functions. Some common ones are: `n()`, `min()`, `max()`, `sum()`, `mean()`, and `quantile()`.\n\n::: callout-warning\nIf you get the answer `NA` from a summary function, that usually means that there are missing values in the columns you were summarising. This may seem counter-intuitive but it is actually very logical if you consider that NA means \"I don't know the value of this cell\" because the average of 1 + 2 + I don't know isn't 1.5, it's \"I don't know\". We'll discuss this more in @sec-missing-values, but you can ignore missing values for many functions by adding the argument `na.rm = TRUE`.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nvalues <- c(1, 2, 4, 3, NA, 2)\nmean(values) # is NA\nmean(values, na.rm = TRUE) # removes NAs first\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA\n[1] 2.4\n```\n\n\n:::\n:::\n\n\n\n\n:::\n\nThis function can be used to answer questions like: How many total live births were there? What are the <a href='https://psyteachr.github.io/glossary/m#mean' target='_blank' class='glossary' title='A descriptive statistic that measures the average value of a set of numbers.'>mean</a> and <a href='https://psyteachr.github.io/glossary/m#median' target='_blank' class='glossary' title='The middle number in a distribution where half of the values are larger and half are smaller.'>median</a> number of births per year? Let's start with a very simple example to calculate the total number of births:\n\n-   The first argument that `summarise()` takes is the data table you wish to summarise, in this case the object `delivery`.\n-   `summarise()` will create a new table. The column names of this new table will be the left hand-side arguments (e.g., `total_births`)\n-   The values of these columns are the result of the summary operation on the right hand-side.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummarise(births,\n          total_births = sum(livebirths))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| total_births|\n|------------:|\n|      1351669|\n\n</div>\n:::\n:::\n\n\n\n\n\nIf you want to summarise by category, you can use the `.by` argument, as long as you have a version of dplyr that is 1.1.0 or above (if not, you can use the method in the next section).\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummarise(births,\n          total_births = sum(livebirths),\n          .by = delivery)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|delivery              | total_births|\n|:---------------------|------------:|\n|Caesarean - Elective  |       156405|\n|Caesarean - Emergency |       209473|\n|Forceps               |       115698|\n|Spontaneous           |       815827|\n|Vacuum                |        50470|\n|Breech                |         3282|\n|Not Known             |          514|\n\n</div>\n:::\n:::\n\n\n\n\n\nIf you want to group by more than one column, use the `c()` function to group the column names.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummarise(births,\n          total_births = sum(livebirths),\n          .by = c(delivery, induced))\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|delivery              |induced     | total_births|\n|:---------------------|:-----------|------------:|\n|Caesarean - Elective  |Not Induced |       154531|\n|Caesarean - Emergency |Induced     |        81812|\n|Caesarean - Emergency |Not Induced |       125973|\n|Forceps               |Induced     |        42440|\n|Forceps               |Not Induced |        72528|\n|Spontaneous           |Induced     |       225033|\n|Spontaneous           |Not Induced |       586595|\n|Vacuum                |Not Induced |        32492|\n|Vacuum                |Induced     |        17714|\n|Breech                |Induced     |          300|\n|Breech                |Not Induced |         2966|\n|Spontaneous           |Unknown     |         4199|\n|Vacuum                |Unknown     |          264|\n|Caesarean - Emergency |Unknown     |         1688|\n|Not Known             |Not Induced |          331|\n|Caesarean - Elective  |Induced     |         1549|\n|Forceps               |Unknown     |          730|\n|Not Known             |Induced     |          146|\n|Breech                |Unknown     |           16|\n|Caesarean - Elective  |Unknown     |          325|\n|Not Known             |Unknown     |           37|\n\n</div>\n:::\n:::\n\n\n\n\n\n## Grouping {#sec-grouping}\n\nYou can also create summary values by group using a combination of `group_by()` and `summarise()`. The function `group_by()` takes an existing data table and converts it into a grouped table, where any operations that are subsequently performed on it are done \"by group\".\n\nIt differs from the `.by` argument to `summarise()` in that it is persistent, so the table stays grouped until you explicitly remove the groups using the `ungroup()` functions, while the `.by` argument only applies to the function it is inside. Most of the code examples you'll see use this style, since the `.by` argument is fairly new.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths %>%\n  group_by(delivery) %>%\n  summarise(births = sum(livebirths)) %>%\n  ungroup()\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|delivery              | births|\n|:---------------------|------:|\n|Spontaneous           | 815827|\n|Caesarean - Emergency | 209473|\n|Forceps               | 115698|\n|Vacuum                |  50470|\n|Caesarean - Elective  | 156405|\n|Breech                |   3282|\n|Not Known             |    514|\n\n</div>\n:::\n:::\n\n\n\n\n\n::: callout-warning\nMake sure you call the `ungroup()` function when you are done with grouped functions. Failing to do this can cause all sorts of mysterious problems if you use that data table later assuming it isn't grouped.\n:::\n\n<details>\n<summary>This is the abridged version! Click for additional context.</summary>\n\nYou might have noticed that the order of the table above is different from the order when using the `.by` argument of `summarise()`. This is because `group_by()` always sorts the values in the grouping columns in ascending order, while `.by` leaves them in the order they are first encountered in your data frame. Use the function `arrange()` to manually change order (see @sec-arrange).\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths %>%\n  group_by(delivery) %>%\n  summarise(births = sum(livebirths)) %>%\n  ungroup() %>%\n  arrange(desc(births)) # sort by number of births in descending order\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|delivery              | births|\n|:---------------------|------:|\n|Spontaneous           | 815827|\n|Caesarean - Emergency | 209473|\n|Caesarean - Elective  | 156405|\n|Forceps               | 115698|\n|Vacuum                |  50470|\n|Breech                |   3282|\n|Not Known             |    514|\n\n</div>\n:::\n:::\n\n\n\n\n</details>\n\n### Multiple groupings\n\nYou can add multiple variables to `group_by()` to further break down your data. For example, the below gives us the number of births broken down by delivery type and year.\n\n-   Reverse the order of `delivery` and financial_year`in`group_by()\\` to see how it changes the output.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths %>%\n  group_by(delivery, financial_year) %>%\n  summarise(n = sum(livebirths)) %>%\n  ungroup()\n```\n:::\n\n\n\n\n\n<details>\n<summary>This is the abridged version! Click for additional context.</summary>\n::: callout-warning\nYou may get the following message when using `summarise()` after `group_by()`.\n\n> `summarise()` has grouped output by 'delivery'. You can override using the `.groups` argument.\n\nTidyverse recently added a message to remind you whether the `summarise()` function automatically ungroups grouped data or not (it may do different things depending on how it's used). You can set the argument `.groups` to \"drop\", \"drop_last\", \"keep\", or \"rowwise\" (see the help for `?summarise`), but it's good practice to explicitly use `ungroup()` when you're done working by groups, regardless.\n:::\n</details>\n\n### Percent by groups\n\nCalculating percent by groups is a great example of the flexibility of `group_by()` but also why you have to be very careful and always check the output of your code.\n\nWhen we just had one variable to count, adding percent was nice and easy:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncount(births, delivery) %>%\n  mutate(percent = n/sum(n)*100)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|delivery              |     n|    percent|\n|:---------------------|-----:|----------:|\n|Spontaneous           | 25607| 26.3780298|\n|Caesarean - Emergency | 22526| 23.2042605|\n|Forceps               | 19041| 19.6143268|\n|Vacuum                | 14573| 15.0117948|\n|Caesarean - Elective  | 12417| 12.7908773|\n|Breech                |  2483|  2.5577634|\n|Not Known             |   430|  0.4429474|\n\n</div>\n:::\n:::\n\n\n\n\n\nWith multiple variables, problems can arise if we use the exact same approach because by default, it will calculate the percent that each row contributes to the dataset as a whole. This might be what you want:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ncount(births, age_group, induced, sort = TRUE)%>%\n  mutate(percent = n/sum(n)*100)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|age_group   |induced     |     n|    percent|\n|:-----------|:-----------|-----:|----------:|\n|25-34       |Not Induced | 20441| 21.0564809|\n|35 and over |Not Induced | 16965| 17.4758182|\n|Under 25    |Not Induced | 16805| 17.3110005|\n|25-34       |Induced     | 15176| 15.6329512|\n|Under 25    |Induced     | 12206| 12.5735241|\n|35 and over |Induced     | 11711| 12.0636196|\n|25-34       |Unknown     |  1940|  1.9984136|\n|35 and over |Unknown     |   916|  0.9435809|\n|Under 25    |Unknown     |   907|  0.9343099|\n|Unknown     |Not Induced |     6|  0.0061807|\n|Unknown     |Induced     |     4|  0.0041204|\n\n</div>\n:::\n:::\n\n\n\n\n\nHowever, it's more likely that you would want to calculate percent by groups. For example, what percent of people in the Induced category were in which age group? Or what percent of 25-34 year olds were induced? To calculate these numbers, we add in a call to `group_by()`:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# group by age, percentages within each age group will sum to 100\ncount(births, age_group, induced)%>% #age then induced\n  group_by(age_group) %>%\n  mutate(percent = n/sum(n)*100)\n\n# group by induced, percentages within each induction group will sum to 100\ncount(births, induced, age_group)%>% #induced then age\n  group_by(induced) %>%\n  mutate(percent = n/sum(n)*100)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|age_group   |induced     |     n|   percent|\n|:-----------|:-----------|-----:|---------:|\n|Under 25    |Not Induced | 16805| 56.170198|\n|Under 25    |Induced     | 12206| 40.798182|\n|Under 25    |Unknown     |   907|  3.031620|\n|25-34       |Not Induced | 20441| 54.426605|\n|25-34       |Induced     | 15176| 40.407913|\n|25-34       |Unknown     |  1940|  5.165482|\n|35 and over |Not Induced | 16965| 57.329684|\n|35 and over |Induced     | 11711| 39.574885|\n|35 and over |Unknown     |   916|  3.095431|\n|Unknown     |Not Induced |     6| 60.000000|\n|Unknown     |Induced     |     4| 40.000000|\n\n</div><div class=\"kable-table\">\n\n|induced     |age_group   |     n|    percent|\n|:-----------|:-----------|-----:|----------:|\n|Not Induced |Under 25    | 16805| 30.9958131|\n|Not Induced |25-34       | 20441| 37.7021967|\n|Not Induced |35 and over | 16965| 31.2909235|\n|Not Induced |Unknown     |     6|  0.0110666|\n|Induced     |Under 25    | 12206| 31.2197867|\n|Induced     |25-34       | 15176| 38.8162775|\n|Induced     |35 and over | 11711| 29.9537049|\n|Induced     |Unknown     |     4|  0.0102310|\n|Unknown     |Under 25    |   907| 24.1031092|\n|Unknown     |25-34       |  1940| 51.5546107|\n|Unknown     |35 and over |   916| 24.3422801|\n\n</div>\n:::\n:::\n\n\n\n\n\n<details>\n<summary>This is the abridged version! Click for additional context.</summary>\n\nIf you have updated <pkg>dyplr</pkg> then you can also use the `.by` argument in `mutate()`:\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# group by age, percentages within each age group will sum to 100\ncount(births, age_group, induced)%>% #age then induced\n  mutate(percent = n/sum(n)*100,\n         .by = age_group)\n\n# group by induced, percentages within each induction group will sum to 100\ncount(births, induced, age_group)%>% #induced then age\n  mutate(percent = n/sum(n)*100,\n         .by = induced)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|age_group   |induced     |     n|   percent|\n|:-----------|:-----------|-----:|---------:|\n|Under 25    |Not Induced | 16805| 56.170198|\n|Under 25    |Induced     | 12206| 40.798182|\n|Under 25    |Unknown     |   907|  3.031620|\n|25-34       |Not Induced | 20441| 54.426605|\n|25-34       |Induced     | 15176| 40.407913|\n|25-34       |Unknown     |  1940|  5.165482|\n|35 and over |Not Induced | 16965| 57.329684|\n|35 and over |Induced     | 11711| 39.574885|\n|35 and over |Unknown     |   916|  3.095431|\n|Unknown     |Not Induced |     6| 60.000000|\n|Unknown     |Induced     |     4| 40.000000|\n\n</div><div class=\"kable-table\">\n\n|induced     |age_group   |     n|    percent|\n|:-----------|:-----------|-----:|----------:|\n|Not Induced |Under 25    | 16805| 30.9958131|\n|Not Induced |25-34       | 20441| 37.7021967|\n|Not Induced |35 and over | 16965| 31.2909235|\n|Not Induced |Unknown     |     6|  0.0110666|\n|Induced     |Under 25    | 12206| 31.2197867|\n|Induced     |25-34       | 15176| 38.8162775|\n|Induced     |35 and over | 11711| 29.9537049|\n|Induced     |Unknown     |     4|  0.0102310|\n|Unknown     |Under 25    |   907| 24.1031092|\n|Unknown     |25-34       |  1940| 51.5546107|\n|Unknown     |35 and over |   916| 24.3422801|\n\n</div>\n:::\n:::\n\n\n\n\n\n## Additional Functions\n<details>\n<summary>This is the abridged version! Click for additional context.</summary>\n\nYou can also use additional functions like `filter()` after `group_by` or with the `.by` argument. You'll learn more about these in @sec-wrangle but briefly:\n\n-   `filter()` keeps observations (rows) according to specified criteria, e.g., all values above 5, or all induced births\n-   `arrange()` sorts the rows by value\n\nYou can combine functions like this to get detailed insights into your data. For example, you can\n\n-   recode the financial year into just the first year, and make it numeric\n-   filter your data to remove unknown ages and delivery types\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths_per_year_type_age <- births %>%\n  mutate(year = str_extract(financial_year, \".{4}\"), # takes first four digits\n         year = as.integer(year)) %>% # transform to numeric\n  filter(age_group != \"Unknown\", # remove unknown\n         delivery != \"Not Known\") %>% # remove not known\n  summarise(n = sum(livebirths),\n            .by = c(year, delivery, age_group)) %>%\n  mutate(pcnt = n / sum(n) * 100, \n         .by = c(year, age_group))\n  \n\n# show just the first 6 rows\nhead(births_per_year_type_age)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n| year|delivery              |age_group   |     n|      pcnt|\n|----:|:---------------------|:-----------|-----:|---------:|\n| 1997|Caesarean - Elective  |25-34       |  2454|  7.114899|\n| 1997|Caesarean - Emergency |25-34       |  3875| 11.234815|\n| 1997|Forceps               |25-34       |  2570|  7.451219|\n| 1997|Spontaneous           |25-34       | 23933| 69.389116|\n| 1997|Vacuum                |25-34       |  1534|  4.447537|\n| 1997|Caesarean - Elective  |35 and over |   801| 10.831643|\n\n</div>\n:::\n:::\n\n\n\n\n\n::: {.callout-note .try}\nRe-write the code above using `group_by()` instead of the `.by` argument?\n:::\n\nNow you can use your skills from @sec-viz to plot the data! The code below has a few elements you haven't seen before. For example, it adds a transparent horizontal line at 0, which is a trick to force all the y-axes to start at 0, but allows different scales per facet. It also angles the text in the x-axis.\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nbirths_per_year_type_age  %>%\n  ggplot(aes(x = year, y = pcnt, color = age_group)) +\n  geom_line() +\n  facet_wrap(~delivery, scales = \"free_y\") +\n  geom_hline(yintercept = 0, color = \"transparent\") + \n  labs(x = NULL, \n       y = \"Percent of Live Births per Year\",\n       color = \"Age Group\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1))\n```\n\n::: {.cell-output-display}\n![](04-summary_files/figure-html/fig-birth-year-type-age-1.png){#fig-birth-year-type-age fig-align='center' width=100%}\n:::\n:::\n\n\n\n\n</details>\n\n## Exercises\n\nTake a break and then try one (or more) of the following:\n\n-   Create an Rmd report that presents the above code with nice formatting. For example, hide the code from the output and format the tables.\n-   Explore the data and add at least one unique insights of your own to the report\n-   Download a different data set from [Scottish Health and Social Care Open Data](https://www.opendata.nhs.scot/) and create summary tables and plots.\n-   If you have data of your own, practice summarising this in R.\n\n<details>\n<summary>This is the abridged version! Click for additional context.</summary>\n### Share on Teams\n\nOnce you're done, share your knitted report and the Rmd file on Teams in the Week 04 channel.\n</details>\n\n## Glossary {#sec-glossary-summary}\n\n\n\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n\n\n|term                                          |definition                                                                                                             |\n|:---------------------------------------------|:----------------------------------------------------------------------------------------------------------------------|\n|[categorical](https://psyteachr.github.io/glossary/c#categorical){target='_blank' class='glossary'}|Data that can only take certain values, such as types of pet.                                                          |\n|[character](https://psyteachr.github.io/glossary/c#character){target='_blank' class='glossary'}|A data type representing strings of text.                                                                              |\n|[csv](https://psyteachr.github.io/glossary/c#csv){target='_blank' class='glossary'}|Comma-separated variable: a file type for representing data where each variable is separated from the next by a comma. |\n|[double](https://psyteachr.github.io/glossary/d#double){target='_blank' class='glossary'}|A data type representing a real decimal number                                                                         |\n|[mean](https://psyteachr.github.io/glossary/m#mean){target='_blank' class='glossary'}|A descriptive statistic that measures the average value of a set of numbers.                                           |\n|[median](https://psyteachr.github.io/glossary/m#median){target='_blank' class='glossary'}|The middle number in a distribution where half of the values are larger and half are smaller.                          |\n|[pipe](https://psyteachr.github.io/glossary/p#pipe){target='_blank' class='glossary'}|A way to order your code in a more readable format using the symbol %>%                                                |\n|[vector](https://psyteachr.github.io/glossary/v#vector){target='_blank' class='glossary'}|A type of data structure that collects values with the same data type, like T/F values, numbers, or strings.           |\n\n\n:::\n:::\n\n\n\n\n\n## Further resources {#sec-resources-summary}\n\n-   [Data transformation cheat sheet](https://raw.githubusercontent.com/rstudio/cheatsheets/main/data-transformation.pdf)\n-   [Chapter 3: Data Transformation](https://r4ds.hadley.nz/data-transform) in *R for Data Science*\n-   [kableExtra vignettes](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html)\n",
    "supporting": [
      "04-summary_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}