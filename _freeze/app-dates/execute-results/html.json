{
  "hash": "8de21b927e2af37f84074fcd14589e3d",
  "result": {
    "markdown": "# Dates and Times {#sec-dates-times}\n\nWorking with dates and times can be a little tricky, but the <pkg>lubridate\", \"https://lubridate.tidyverse.org/\")` package is there to help. Their website has a helpful [cheatsheet](https://rawgit.com/rstudio/cheatsheets/main/lubridate.pdf) and you can view a tutorial by typing `vignette(\"lubridate\")` in the console pane. The [Dates and Times](https://r4ds.had.co.nz/dates-and-times.html){target=\"_blank\"} in R for Data Science also gives a helpful overview.\n\nThis appendix is a quick intro to some of the most useful functions for making reproducible reports.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# packages needed for this appendix\nlibrary(tidyverse)\nlibrary(lubridate)\n```\n:::\n\n\n## Formats\n\nWhile there is only one correct way to write date (The ISO 8601 format of \"YYYY-MM-DD\"), dates can be found in many formats. When you are reading a data file, you might need to specify the date format so it can be read properly. Date format specification uses abbreviations to represent the different ways people can write. the year, month, and day (as well as hours, minutes, and seconds). For example, the date `2023-01-03` is represented by the formatting string `\"%Y-%m-%d`. The fastest way to find the list of formatting abbreviations is to look in the help for the function `col_date()`.\n\n\n::: {.cell layout-align=\"center\" filename='Run in the console'}\n\n```{.r .cell-code}\n?col_date\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# create a table with some different date formats\ndate_formats <- tibble(\n  best = \"2022-01-03\",\n  ok = \"2022 January 3\",\n  bad = \"January 3, 2022\",\n  terrible = \"Mon is 3 22 1\"\n)\n\n# save it as a CSV file\nwrite_csv(date_formats, \"data/date_formats.csv\")\n\n# read it in\ndf <- read_csv(\"data/date_formats.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 1 Columns: 4\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): ok, bad, terrible\ndate (1): best\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nYou can see that only the first column read as a date, and the rest read as characters. You can set the date format using the `col_types` argument and two helper functions, `cols()` and `col_date()`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nct <- cols(ok = col_date(\"%Y %B %d\"),\n           bad = col_date(\"%B %d, %Y\"),\n           terrible = col_date(\"%a is %m %y %d\"))\n\nread_csv(\"data/date_formats.csv\", \n         col_types = ct)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|best       |ok         |bad        |terrible   |\n|:----------|:----------|:----------|:----------|\n|2022-01-03 |2022-01-03 |2022-01-03 |2022-03-01 |\n\n</div>\n:::\n:::\n\n\n\n## Parsing\n\nThe `ymd` functions can deal with almost all date formats, regardless of the punctuation used in the format. All of the examples below produce a date in the standard format \"2022-01-03\".\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# year-month-day orders\nymd(\"22 Jan 3\")\nymd(\"2022 January 3rd\")\n\n# month-day-year orders\nmdy(\"January 3, 2022\")\nmdy(\"Jan/03/22\")\n\n# day-month-year orders\ndmy(\"3JAN22\")\ndmy(\"3rd of January in the year 2022\")\n```\n:::\n\n\n::: {.callout-note .try}\nSee if you can make a date format that one of the parsers *can't* handle.\n:::\n\nThere are similar functions for date/times, too.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nymd_hms(\"2022 Jan 3, 6:05 and 20s pm\")\nmdy_h(\"January 3rd, 2022 at 6pm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-01-03 18:05:20 UTC\"\n[1] \"2022-01-03 18:00:00 UTC\"\n```\n:::\n:::\n\n\nThe date/time functions can also take a timezone argument. If you don't specify it, it defaults to \"UTC\".\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nymd_hm(\"2022-01-03 18:05\", tz = \"GMT\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-01-03 18:05:00 GMT\"\n```\n:::\n:::\n\n\n## Get Parts\n\nYou frequently need to extract parts of a date/time for plotting. The following functions extract specific parts of a date or datetime object. This is a godsend for those of us who never have a clue what week of the year it is today.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# get the date and time when this function is run\nnow <- now(tzone = \"GMT\")\n\n# get separate parts\ntime_parts <- list(\n  second  = second(now),\n  minute  = minute(now),\n  hour    = hour(now),\n  day     = day(now),  # day of the month (same as mday())\n  wday    = wday(now), # day of the week\n  yday    = yday(now), # day of the year\n  week    = week(now),\n  isoweek = isoweek(now), # ISO 8501 week calendar (Monday start)\n  epiweek = epiweek(now), # CDC epidemiological week (Sunday Start)\n  month   = month(now),\n  year    = year(now),\n  tz      = tz(now)\n)\n\nstr(time_parts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of 12\n $ second : num 47.3\n $ minute : int 10\n $ hour   : int 15\n $ day    : int 20\n $ wday   : num 4\n $ yday   : num 80\n $ week   : num 12\n $ isoweek: num 12\n $ epiweek: num 12\n $ month  : num 3\n $ year   : num 2024\n $ tz     : chr \"GMT\"\n```\n:::\n:::\n\n\n\nThe `month()` and `wday()` functions can return factor labels.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\njan1 <- ymd(20220101)\nwday(jan1, label = TRUE)\nwday(jan1, label = TRUE, abbr = TRUE)\nmonth(jan1, label = TRUE)\nmonth(jan1, label = TRUE, abbr = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Sat\nLevels: Sun < Mon < Tue < Wed < Thu < Fri < Sat\n[1] Sat\nLevels: Sun < Mon < Tue < Wed < Thu < Fri < Sat\n[1] Jan\n12 Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < ... < Dec\n[1] Jan\n12 Levels: Jan < Feb < Mar < Apr < May < Jun < Jul < Aug < Sep < ... < Dec\n```\n:::\n:::\n\n\n::: {.callout-note .try}\nWhat day of the week were you born?\n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nbirthdate <- ymd(19761118) # put your own birthdate here\nwday(birthdate, label = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Thu\nLevels: Sun < Mon < Tue < Wed < Thu < Fri < Sat\n```\n:::\n\n:::\n:::\n\n:::\n\n\n\n## Date Arithmetic\n\nYou can add and subtract dates. For example, you can get the dates two weeks from today by adding `weeks(2)` to `today()`. You can probably guess how to add and subtract seconds, minutes, days, months, and years.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntoday() + weeks(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2024-03-27\"\n```\n:::\n:::\n\n\n::: {.callout-note .try}\nWhat day of the week will your 100th birthday be? \n\n\n::: {.cell layout-align=\"center\" webex.hide='true'}\n::: {.callout-note collapse='true'}\n## Solution\n\n```{.r .cell-code}\nbirthdate <- ymd(19761118) # put your own birthdate here\ncentennial <- birthdate + years(100)\nwday(centennial, label = TRUE, abbr = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Wednesday\n7 Levels: Sunday < Monday < Tuesday < Wednesday < Thursday < ... < Saturday\n```\n:::\n\n:::\n:::\n\n:::\n\n::: {.callout-warning}\nWhat do you think will happen if you subtract one month from March 31st? You get NA, since February doesn't have a 31st day.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nymd(20220331) - months(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nUse the special date operators `%m+%` and `%m-%` to add and subtract months without risking an impossible date.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nymd(20220331) %m-% months(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-02-28\"\n```\n:::\n:::\n\n:::\n\n### First and last of month\n\nFor things like billing, you might need to find the first or last days of the current, previous, or next month. The `rollback()` and `rollforward()` functions are easier than trying to parse dates.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nd <- ymd(\"2022-01-24\")\nrollback(d)                          # last day of the previous month\nrollforward(d)                       # last day of the current month\nrollback(d, roll_to_first = TRUE)    # first day of the current month\nrollforward(d, roll_to_first = TRUE) # first day of the next month\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2021-12-31\"\n[1] \"2022-01-31\"\n[1] \"2022-01-01\"\n[1] \"2022-02-01\"\n```\n:::\n:::\n\n\n\n### Rounding\n\nYou can round dates and times to the nearest unit. This can be useful when you have, for example, time measured to the nearest second, but want to group data by the nearest hour, rather than extract the hour component. \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nymd_hm(\"2022-01-24 10:25\") %>% round_date(unit = \"hour\")\nymd_hm(\"2022-01-24 10:30\") %>% round_date(unit = \"hour\")\nymd_hm(\"2022-01-24 10:35\") %>% round_date(unit = \"hour\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-01-24 10:00:00 UTC\"\n[1] \"2022-01-24 11:00:00 UTC\"\n[1] \"2022-01-24 11:00:00 UTC\"\n```\n:::\n:::\n\n\n## Internationalisation\n\nYou may need to work with dates from a different locale than your computer's defaults, such as dates written in French or Russian. Or your computer may have a non-English locale. Set the `locale` argument to the relevant language code.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nymd(\"2022 January 24\", locale = \"en_GB\")\nymd(\"2022 Janvier 24\", locale = \"fr_FR\")\nwday(\"2022-01-03\", label = TRUE, locale = \"ru_RU\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"2022-01-24\"\n[1] \"2022-01-24\"\n[1] пн\nLevels: вс < пн < вт < ср < чт < пт < сб\n```\n:::\n:::\n\n\nSome of the locale functions only work on unix-based machines, like Macs or machines running linux.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# check your own locale; doesn't work for Windows\nlocale()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<locale>\nNumbers:  123,456.78\nFormats:  %AD / %AT\nTimezone: UTC\nEncoding: UTF-8\n<date_names>\nDays:   Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday\n        (Thu), Friday (Fri), Saturday (Sat)\nMonths: January (Jan), February (Feb), March (Mar), April (Apr), May (May),\n        June (Jun), July (Jul), August (Aug), September (Sep), October\n        (Oct), November (Nov), December (Dec)\nAM/PM:  AM/PM\n```\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# check which locales are available on your computer\n# doesn't work for Windows\nsystem(\"locale -a\")\n```\n:::\n\n\n\n\n\n## Example\n\nLet's work through some examples with downloaded tweets from the [class data](data/data.zip).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# read all metrics files in data/tweets/\ntweets <- list.files(\n  path = \"data/tweets\", \n  pattern = \"^tweet_activity_metrics\",\n  full.names = TRUE\n) %>%\n  map_df(read_csv) %>%\n  select(!starts_with(\"promoted\"))\n```\n:::\n\n\nThe `time` column is already in date/time (POSIXct) format, but what if we wanted to plot tweets by hour for each day of the week? \n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntweets %>%\n  mutate(weekday = wday(time, label = TRUE),\n         hour = hour(time)) %>%\n  ggplot(aes(x = hour, fill = weekday)) +\n  geom_bar(size = 1, alpha = 0.5, show.legend = FALSE) +\n  facet_grid(~weekday) +\n  scale_fill_manual(values = rainbow(7)) +\n  scale_x_continuous(breaks = seq(0, 24, 4))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](app-dates_files/figure-html/weekday-tweets-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\nA nice side-effect of using the lubridate function to get days of the week or months of the year is that the results are an ordered factor, so display correctly in a plot. Let's display the months in Greek (if that's available on your system).\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntweets %>%\n  mutate(month = month(time, label = TRUE, abbr = FALSE, locale = \"el_GR.UTF-8\")) %>%\n  ggplot(aes(x = month, fill = month)) +\n  geom_bar(show.legend = FALSE) +\n  scale_x_discrete(name = NULL, guide = guide_axis(n.dodge=2))\n```\n\n::: {.cell-output-display}\n![](app-dates_files/figure-html/month-tweets-1.png){fig-align='center' width=100%}\n:::\n:::\n",
    "supporting": [
      "app-dates_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}